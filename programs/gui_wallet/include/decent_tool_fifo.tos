/*
 *	File: decent_tool_fifo.tos
 *
 *	Created on: 04 Feb 2017
 *	Created by: Davit Kalantaryan (Email: davit.kalantaryan@desy.de)
 *
 *  This file implements ...
 *
 */
#ifndef DECENT_TOOL_FIFO_TOS
#define DECENT_TOOL_FIFO_TOS

#ifndef DECENT_TOOL_FIFO_HPP
//#error this file could not be include directly
#include "decent_tool_fifo.hpp"
#endif  // #ifndef DECENT_TOOL_FIFO_HPP

#include <stdio.h>
#include <stdarg.h>
#include "debug_decent_application.h"


#ifdef USE_FIFO_SIMPLE


template <typename TypeFifoVrb>
decent::tools::FiFo<TypeFifoVrb>::fifoListItem<TypeFifoVrb>::fifoListItem(const TypeFifoVrb& a_inp)
    :
      next(NULL),elemnt(a_inp)
{
    //
}


template <typename TypeFifoVrb>
decent::tools::FiFo<TypeFifoVrb>::fifoListItem<TypeFifoVrb>::~fifoListItem()
{
    __DEBUG_APP2__(1,"this=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",this);
}



/*///////////////////////////////////////////////////////////////*/


template <typename TypeFifoVrb>
decent::tools::FiFo<TypeFifoVrb>::FiFo()
    :
      m_pFirstTask(NULL),
      m_pLastTask(NULL)
{
}


template <typename TypeFifoVrb>
decent::tools::FiFo<TypeFifoVrb>::~FiFo()
{
    fifoListItem<TypeFifoVrb> *pItemNext;

    m_task_mutex.lock();
    while(m_pFirstTask)
    {
        pItemNext = m_pFirstTask->next;
        delete m_pFirstTask;
        m_pFirstTask = pItemNext;
    }
    m_task_mutex.unlock();
}


template <typename TypeFifoVrb>
bool decent::tools::FiFo<TypeFifoVrb>::GetFirstTask(TypeFifoVrb* a_pFirstElementBuffer)
{
    bool bRet(false);
    fifoListItem<TypeFifoVrb>* pItemToDelete = NULL;

    //printf("line=%d\n",__LINE__);

    m_task_mutex.lock();
    if(m_pFirstTask)
    {
        pItemToDelete = m_pFirstTask;
        a_pFirstElementBuffer = m_pFirstTask->elemnt;
        m_pFirstTask = m_pFirstTask->next;
        delete pItemToDelete;
        bRet = true;
    } // if(m_pFirstTask)
    m_task_mutex.unlock();

    return bRet;
}


template <typename TypeFifoVrb>
void decent::tools::FiFo<TypeFifoVrb>::AddNewTask(const TypeFifoVrb& a_inp)
{

    fifoListItem<TypeFifoVrb>* pNewItem = new fifoListItem<TypeFifoVrb>(a_inp);

    m_task_mutex.lock();
    if(!m_pFirstTask)
    {
        m_pFirstTask = m_pLastTask = pNewItem;
    }
    else
    {
        m_pLastTask->next = pNewItem;
        m_pLastTask = pNewItem;
    }
    m_task_mutex.unlock();

    __DEBUG_APP2__(_DEF_LOG_LEVEL_,"this=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",this);

}


#else  // #ifdef USE_FIFO_SIMPLE


template <typename TypeInp, typename TypeTaskFnc>
decent::tools::taskListItem<TypeInp,TypeTaskFnc>::taskListItem(TypeTaskFnc a_fn_tsk_dn,const TypeInp& a_inp,
                                                               void* a_owner,void* a_clbArg)
    :
      next(NULL),owner(a_owner),callbackArg(a_clbArg),input(a_inp),fn_tsk_dn2(a_fn_tsk_dn)
{
    //
}


template <typename TypeInp, typename TypeTaskFnc>
decent::tools::taskListItem<TypeInp,TypeTaskFnc>::~taskListItem()
{
    __DEBUG_APP2__(1,"this=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",this);
}


/*////////////////////////////////////////////////////////////////*/


template <typename TypeInp, typename TypeTaskFnc>
decent::tools::FiFo<TypeInp,TypeTaskFnc>::FiFo()
    :
      m_InitialTaskBuffer(NULL,TypeInp()),
      m_pFirstTask(NULL),
      m_pLastTask(NULL)
{
}


template <typename TypeInp, typename TypeTaskFnc>
decent::tools::FiFo<TypeInp,TypeTaskFnc>::~FiFo()
{
    taskListItem<TypeInp,TypeTaskFnc> *pItemTodelete, *pItemTemp;

    m_task_mutex.lock();
    pItemTodelete = m_pFirstTask ? m_pFirstTask->next : NULL;
    __DEBUG_APP2__(1,"pItemTodelete=%p ",pItemTodelete);
    while(pItemTodelete)
    {
        __DEBUG_APP2__(_DEF_LOG_LEVEL_,"dltt=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",pItemTodelete);
        pItemTemp = pItemTodelete->next;
        if(pItemTodelete != (&m_InitialTaskBuffer)){delete pItemTodelete;}
        pItemTodelete = pItemTemp;
    }
    m_task_mutex.unlock();
}


template <typename TypeInp, typename TypeTaskFnc>
bool decent::tools::FiFo<TypeInp,TypeTaskFnc>::GetFirstTask(decent::tools::taskListItem<TypeInp,TypeTaskFnc>* a_pFirstTaskBuffer)
{
    bool bRet(false);
    struct taskListItem<TypeInp,TypeTaskFnc>* pTmp = NULL;

    //printf("line=%d\n",__LINE__);

    m_task_mutex.lock();
    if(m_pFirstTask)
    {
        //printf("line=%d\n",__LINE__);
        //memcpy(a_pFirstTaskBuffer,m_pFirstTask,sizeof(struct taskListItem<TypeInp,TypeTaskFnc>));
        *a_pFirstTaskBuffer = *m_pFirstTask;
        if(m_pFirstTask->next)
        {
            pTmp = m_pFirstTask->next;
            //memcpy(m_pFirstTask,m_pFirstTask->next,sizeof(struct taskListItem<TypeInp,TypeTaskFnc>));
            *m_pFirstTask = *(m_pFirstTask->next);
            if(pTmp != (&m_InitialTaskBuffer)){delete pTmp;}
            __DEBUG_APP2__(_DEF_LOG_LEVEL_,"dltt=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",pTmp);
        }
        else {m_pFirstTask = NULL;}
        bRet = true;
    } // if(m_pFirstTask)
    m_task_mutex.unlock();

    return bRet;
}


template <typename TypeInp, typename TypeTaskFnc>
void decent::tools::FiFo<TypeInp,TypeTaskFnc>::AddNewTask(int a_nType,const TypeInp& a_inp, void* a_owner, void* a_clbData,...)
{
    TypeTaskFnc fpTaskDone;
    va_list aFunc;

    va_start( aFunc, a_clbData );
    fpTaskDone = va_arg( aFunc, TypeTaskFnc);
    va_end( aFunc );

    m_task_mutex.lock();
    if(!m_pFirstTask)
    {
        //m_InitialTaskBuffer.next = NULL;
        m_pFirstTask = m_pLastTask = &m_InitialTaskBuffer;

        m_pLastTask->next = NULL;
        m_pLastTask->owner = a_owner;
        m_pLastTask->callbackArg = a_clbData;
        m_pLastTask->input = a_inp;
        m_pLastTask->fn_tsk_dn2 = fpTaskDone;
    }
    else
    {
        m_pLastTask->next = new taskListItem<TypeInp,TypeTaskFnc>(fpTaskDone,a_inp,a_owner,a_clbData);
        m_pLastTask = m_pLastTask->next;
    }
    m_pLastTask->type = a_nType;
    m_task_mutex.unlock();

    __DEBUG_APP2__(_DEF_LOG_LEVEL_,"this=%p    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ",this);

}


#endif  // #ifdef USE_FIFO_SIMPLE


#endif // DECENT_TOOL_FIFO_TOS
